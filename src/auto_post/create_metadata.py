"""
create_metadata.py
------------------
Generate YouTube metadata (title + description) for a Lo‑Fi video.

* Randomly pick a record from lofi_type.jsonl to get `type` and `music_prompt`
* Read `tracks_info.json` (generated by combine_audio.py) to build a timestamped
  track‑list
* Use OpenAI API to create an engaging title and a short English description
* Output files are stored under ./data/outputs_metadata

Run:
python create_metadata.py --temperature 0.7
"""

import argparse
import json
import logging
import os
import random
from datetime import datetime
from pathlib import Path
from typing import Dict, List

import requests
from dotenv import load_dotenv

from .config import Config

# Load environment variables
load_dotenv()

# Logger
logger = logging.getLogger(__name__)

# ------------------------------------------------------------------
# Config paths
# ------------------------------------------------------------------

BASE_DIR = Path(__file__).parent.parent
JSONL_PATH = Config.JSONL_PATH
TRACKS_JSON = BASE_DIR / "data" / "outputs_audio" / "tracks_info.json"
OUTPUT_DIR = BASE_DIR / "data" / "outputs_metadata"
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# OpenAI configuration
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_API_URL = "https://api.openai.com/v1/chat/completions"
OPENAI_MODEL = "gpt-3.5-turbo"  # You can change to "gpt-4" if needed


# ------------------------------------------------------------------
# Helper I/O
# ------------------------------------------------------------------
def load_random_lofi() -> Dict:
    lines = [
        json.loads(line)
        for line in JSONL_PATH.read_text(encoding="utf-8").splitlines()
        if line.strip()
    ]
    return random.choice(lines)


def load_tracks() -> List[Dict]:
    if not TRACKS_JSON.exists():
        logger.warning("⚠️  tracks_info.json not found")
        return []
    with open(TRACKS_JSON, encoding="utf-8") as f:
        return json.load(f)


def format_timestamp(seconds: float) -> str:
    m, s = divmod(int(seconds), 60)
    return f"{m}:{s:02d}"


def build_tracklist(tracks: List[Dict]) -> str:
    if not tracks:
        return "TRACKLIST:\n[No track information available]"
    lines = ["TRACKLIST:"]
    for t in tracks:
        ts = format_timestamp(t["start_time"])
        lines.append(f"{ts} - {t['title']}")
    return "\n".join(lines)


# ------------------------------------------------------------------
# OpenAI API helpers
# ------------------------------------------------------------------
def call_openai(prompt: str, max_tokens: int = 100, temp: float = 0.7) -> str:
    """Call OpenAI API to generate text"""
    if not OPENAI_API_KEY:
        raise ValueError("OPENAI_API_KEY environment variable is not set")

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {OPENAI_API_KEY}",
    }

    payload = {
        "model": OPENAI_MODEL,
        "messages": [{"role": "user", "content": prompt}],
        "temperature": temp,
        "max_tokens": max_tokens,
    }

    try:
        r = requests.post(OPENAI_API_URL, json=payload, headers=headers, timeout=60)
        if r.status_code == 200:
            data = r.json()
            if "choices" in data and data["choices"]:
                text = data["choices"][0]["message"]["content"]
                return text.strip()
            else:
                logger.warning(f"Unexpected response format: {data}")
                return ""
        else:
            logger.warning(f"API call failed ({r.status_code}): {r.text}")
            return ""
    except Exception as e:
        logger.error(f"API call error: {e}")
        return ""


# ------------------------------------------------------------------
# Prompt builders
# ------------------------------------------------------------------
def title_prompt(lofi_type: str, music_prompt: str) -> str:
    return (
        "Generate a single, catchy YouTube video title for a lo‑fi hip‑hop mix.\n"
        f"Style/Type: {lofi_type}\n"
        f"Music prompt: {music_prompt}\n"
        "Requirements:\n"
        "- Return ONLY ONE title\n"
        "- 60–100 characters\n"
        "- No hashtags\n"
        "- No bullet points or multiple options\n"
        "- No explanatory text\n"
        "Title:"
    )


def extract_title(text):
    """
    生成されたテキストからタイトルを抽出する

    Args:
        text (str): 生成されたテキスト

    Returns:
        str: 抽出されたタイトル
    """
    # テキストをクリーンアップ
    text = text.strip()

    # "Title:" で始まる行を探す
    lines = text.split("\n")
    for line in lines:
        line = line.strip()
        if line.startswith("Title:"):
            title = line.replace("Title:", "").strip()
            # 余分な引用符や記号を削除
            title = title.strip("\"'")
            # 特殊文字を削除
            title = "".join(c for c in title if c.isalnum() or c.isspace() or c == "-")
            return title

    # タイトルが見つからない場合は最初の非空行を使用
    for line in lines:
        line = line.strip()
        if line and not line.startswith("*") and not line.startswith("**"):
            # 余分な引用符や記号を削除
            title = line.strip("\"'")
            # 特殊文字を削除
            title = "".join(c for c in title if c.isalnum() or c.isspace() or c == "-")
            return title

    return ""


def description_prompt(lofi_type: str, music_prompt: str) -> str:
    return (
        "Write an engaging YouTube video description (English, 2–3 sentences) "
        "for a lo‑fi hip‑hop mix.\n"
        f"Style/Type: {lofi_type}\n"
        f"Music prompt: {music_prompt}\n"
        "Focus on atmosphere & study/work benefits. No hashtags.\n"
        "Description:"
    )


# ------------------------------------------------------------------
# Main
# ------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(description="YouTube metadata generator")
    parser.add_argument("--temperature", type=float, default=0.7)
    args = parser.parse_args()

    record = load_random_lofi()
    lofi_type = record["type"]
    music_prompt = record["music_prompt"]

    # title + description
    raw_title = call_openai(title_prompt(lofi_type, music_prompt), 80, args.temperature)
    title = extract_title(raw_title)

    raw_desc = call_openai(
        description_prompt(lofi_type, music_prompt), 200, args.temperature
    )
    description = raw_desc.replace("Description:", "").strip()

    # tracklist
    tracks = load_tracks()
    tracklist = build_tracklist(tracks)

    # post detail
    memo_file = BASE_DIR / "memo" / "post_detail.txt"
    memo = memo_file.read_text(encoding="utf-8") if memo_file.exists() else ""
    post_detail = f"{title}\n\n{description}\n\n{tracklist}\n\n{memo}"

    # save
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    base = f"{lofi_type.lower()}_{timestamp}"
    (OUTPUT_DIR / f"{base}_title.txt").write_text(title, encoding="utf-8")
    (OUTPUT_DIR / f"{base}_description.txt").write_text(description, encoding="utf-8")
    (OUTPUT_DIR / f"{base}_tracklist.txt").write_text(tracklist, encoding="utf-8")
    (OUTPUT_DIR / f"{base}_post_detail.txt").write_text(post_detail, encoding="utf-8")

    meta = {
        "type": lofi_type,
        "music_prompt": music_prompt,
        "title": title,
        "description": description,
        "tracklist": tracklist,
        "post_detail": post_detail,
        "temperature": args.temperature,
        "created_at": timestamp,
    }
    with open(OUTPUT_DIR / f"{base}_metadata.json", "w", encoding="utf-8") as f:
        json.dump(meta, f, ensure_ascii=False, indent=2)

    logger.info("=== Generated Metadata ===")
    logger.info("Title: %s", title)
    logger.info("Description: %s ...", description[:120])
    logger.info("Saved to %s", OUTPUT_DIR)


def create_metadata(
    output_dir: str,
    tracks_json: str,
    lofi_type: str,
    music_prompt: str,
    api_url: str,
    temperature: float,
) -> Path:
    # Note: api_url parameter is kept for compatibility but not used

    # Convert string paths to Path objects
    output_dir = Path(output_dir)
    tracks_json = Path(tracks_json)

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # title + description
    raw_title = call_openai(title_prompt(lofi_type, music_prompt), 80, temperature)
    title = extract_title(raw_title)

    raw_desc = call_openai(
        description_prompt(lofi_type, music_prompt), 200, temperature
    )
    description = raw_desc.replace("Description:", "").strip()

    # tracklist
    if not tracks_json.exists():
        logger.warning("⚠️  tracks_info.json not found")
        raise FileNotFoundError(f"tracks_info.json not found at: {tracks_json}")
    with open(tracks_json, encoding="utf-8") as f:
        tracks = json.load(f)
    tracklist = build_tracklist(tracks)

    # post detail
    memo_file = BASE_DIR / "memo" / "post_detail.txt"
    memo = memo_file.read_text(encoding="utf-8") if memo_file.exists() else ""
    post_detail = f"{title}\n\n{description}\n\n{tracklist}\n\n{memo}"

    # save
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    (output_dir / "title.txt").write_text(title, encoding="utf-8")
    (output_dir / "description.txt").write_text(description, encoding="utf-8")
    (output_dir / "tracklist.txt").write_text(tracklist, encoding="utf-8")
    (output_dir / "post_detail.txt").write_text(post_detail, encoding="utf-8")

    meta = {
        "type": lofi_type,
        "music_prompt": music_prompt,
        "title": title,
        "description": description,
        "tracklist": tracklist,
        "post_detail": post_detail,
        "temperature": temperature,
        "created_at": timestamp,
    }
    with open(output_dir / "metadata.json", "w", encoding="utf-8") as f:
        json.dump(meta, f, ensure_ascii=False, indent=2)

    logger.info("=== Generated Metadata ===")
    logger.info("Title: %s", title)
    logger.info("Description: %s ...", description[:120])
    logger.info("Saved to %s", output_dir)

    return output_dir / "metadata.json"


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s %(levelname)s %(name)s: %(message)s",
    )
    main()
